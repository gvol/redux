# DESCRIPTION

This command can be invoked as `redux redo` or, through an installed symlink, as `redo`.

A redo target is produced by an sh script whose name has a '.do' file extension
and, as such, is called a do script.

For a given target named `target`, the corresponding do file may be named,
in order of decreasing specificity, `target.do` or `default.do`.

For a given target named `target.ext`, the corresponding do file may be named,
in order of decreasing specificity, `target.ext.do`, `default.ext.do` or, finally, `default.do`.

For targets with multiple extensions, the corresponding do files may be named,
in order of decreasing specificity, `target.ext.do` where `ext` is the full extension,
followed by default do files with shorter and shorter suffixes of the extension, finally
ending in `default.do`. For example, the target `file.x.y.z` results in a search for
the following do scripts:

  file.x.y.z.do
  default.x.y.z.do
  default.y.z.do
  default.z.do
  default.do

Redo searches for each of these script files, in order of specificity, starting in the target's directory
and moving into parent directories. The search stops when a script is found or when the project
root directory has been unsuccessfully searched.

If the do script is not found but the target file exists on disk, it is
considered a source file not generated by script and its metadata is
stored in the database.  The file will be subsequently watched for changes.

In the case where the script is found, it is assumed to be an sh script and executed with three arguments:

$1 = path to target, relative to do script directory 
$2 = target basename, also relative to do script directory
$3 = temporary output file name

For compatability with existing do scripts, the value of `$2` depends
on which do script is used as well as on file extensions.

1. If a target uses a specific do script, `$2` is the same as the target
2. If a target uses a default script, `$2` then more specific scripts generate
   shorter values for `$2`.

This chart shows how target and do filenames interact to produce $2.

  Target        Do              Arg2
  blenny        blenny.do       blenny
  blenny        default.do      blenny

  blenny.a      blenny.a.do     blenny.a
  blenny.a      default.a.do    blenny
  blenny.a      default.do      blenny.a

  blenny.a.b    blenny.a.b.do   blenny.a.b
  blenny.a.b    default.a.b.do  blenny
  blenny.a.b    default.b.do    blenny.a
  blenny.a.b    default.do      blenny.a.b

  etc...

The script is executed by /bin/sh with the current working directory (cwd) set to its directory
and with stdout opened to a temporary file (which is unnamed and different from $3).
It is normally expected to produce output on stdout or write to the file specified by its $3 parameter.
It is an error for a script to write to both outputs.

If the script completes successfully, redo chooses the correct output, renames the temporary file
to the target file and updates its database with the new file's metadata record.
Since only one of the two temporary files can have content, redo has no trouble selecting the correct one.
Conversely, if neither file has content, then either is a valid candidate.

In the do file, which is an sh script, the line 

    redo-ifchange A B C

specifies the files A, B, and C as prerequisites for the target file.

Similarly, a call to 

    redo-ifcreate A

specifies that the target should be rebuilt when the non-existent file A appears or is deleted.

As a special case, a do file whose name is prefixed with '@' is run for
side effect.  redux does not create a temporary file when running such
a file and uses '/dev/stdout' as the output file name so its
output is visible but is otherwise not saved.
While the $3 parameter is provided for consistency, it is an error for a task script
to write to it since its output is discarded.

A call to redo without an argument will search for a file named `@all.do`
in the current directory.

A '@' prefixed task is analogous to a `.PHONY` target in make.
Any do file can also be run as a task by invoking 'redo' with the '-task' flag.

# ENVIRONMENT VARIABLES

The -verbose variable can be set with the environment variable `REDO_VERBOSE`.
The value of the variable is not relevant, but its length corresponds to the
intensity of verbosity. For example, `REDO_VERBOSE=xx` is comparable
to invoking redo with the arguments '-verbose -verbose'.

The -sh variable can be set with the environment variable `REDO_SHELL_ARGS`.
This can be used to pass the '-v' or '-x' options, among others,  to the shell (/bin/sh).
redo prepends a '-' to the variable if necessary, so '-xv' could also be specified as 'xv'

The -debug option can be set with the environment variable `REDO_DEBUG`.
The value is not relevant, merely its presence. `REDO_DEBUG=true` works fine.

The `REDO_TMP_DIR` environment variable, which does not have a corresponding flag, can be set
to control where redo creates temporary output files. The specified directory must exist and be writable
to the redo process. This may be useful if /tmp is mounted on a fast device such as a ram disk
or solid state drive (SSD).
